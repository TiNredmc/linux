// SPDX-License-Identifier: GPL-2.0
/*
 * Sharp Memory Display Driver.
 *
 * In this case I'm testing with LS027B7DH01
 * But it should work with others by changing 
 * W x H Display resolution
 *
 * Copyright (c) 2021 Thipok Jiamjarapan
 * <thipok17@gmail.com> 
 *
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/string.h>

#include <linux/vmalloc.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/fb.h>

#include <linux/of_device.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <linux/spi/spi.h>
#include <linux/pwm.h>
#include <linux/delay.h>
#include <linux/uaccess.h>

#include <video/sharp_memlcd.h>

//LSB First
u8 MLCD_UD = 0x80; // Display update command 0x80(send LSB as MSB).
u8 MLCD_MC = 0x20; // Dislay internal mem clear 0x20
u8 MLCD_DM = 0x00; // Dummy byte (sending after data update)


#ifndef CONFIG_SHARP_MLCD_W
#define CONFIG_SHARP_MLCD_W 400
#endif

#ifndef CONFIG_SHARP_MLCD_H
#define CONFIG_SHARP_MLCD_H 240
#endif

#define MLCD_RSIZE (uint8_t)(CONFIG_SHARP_MLCD_W / 8)
#define MLCD_BUFSIZE MLCD_RSIZE * CONFIG_SHARP_MLCD_H


//VCOM inverter control, Required for display refreshing
//In case of no PWM HW support 
#define EXTCOM_HI 0x40
#define EXTCOM_LO 0x00


static const struct fb_fix_screeninfo memlcdfb_fix  = {
	.id = 			"SHARP_MLCDFB",
	.type = 		FB_TYPE_PACKED_PIXELS,
	.visual = 		FB_VISUAL_MONO10, // Monochrome Display.
	.xpanstep = 		0,
	.ypanstep = 		0,
	.ywrapstep = 		0,
	.line_length =		MLCD_RSIZE,
	.accel = 		FB_ACCEL_NONE,
};

static const struct fb_var_screeninfo memlcdfb_var  = {
	.xres = 		CONFIG_SHARP_MLCD_W,
	.yres = 		CONFIG_SHARP_MLCD_H,
	.xres_virtual =		CONFIG_SHARP_MLCD_W,
	.yres_virtual = 	CONFIG_SHARP_MLCD_H,
	/* color pixel format */
	.bits_per_pixel = 	1,
	.grayscale      = 1,
	.red            = {
		.offset = 0,
		.length = 1,
		.msb_right = 0,
	},
	.green          = {
		.offset = 0,
		.length = 1,
		.msb_right = 0,
	},
	.blue           = {
		.offset = 0,
		.length = 1,
		.msb_right = 0,
	},
	.left_margin = 		0,
	.right_margin =		0,
	.upper_margin = 	0,
	.lower_margin = 	0,
	.vmode =		FB_VMODE_NONINTERLACED,
};

static const unsigned char msb2lsb[] = 
{
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

// PWM for display refreshing.
static void memlcdfb_pwm_on(struct memlcdfb_par *par){
	struct pwm_args pargs;

	pwm_apply_args(par->pwm);

	pwm_get_args(par->pwm, &pargs);

	par->pwm_period = pargs.period;
	pwm_config(par->pwm, par->pwm_period / 2, par->pwm_period);// generates 50% duty cycle.

	pwm_enable(par->pwm);
}

/* Turn the disply and PWM on
 */
static int memlcdfb_init(struct memlcdfb_par *par){
	int ret;
	// EXTCOMIN signal generated by using PWM. Fixed at 60Hz with 1/2 duty cycle
	memlcdfb_pwm_on(par);
	printk("MLCD PWM ON\n");

	par->ssbuf[0] = MLCD_MC;
	par->ssbuf[1] = MLCD_DM;

	// Display memory clear, send multiple times as SPI workaround.
	gpio_set_value_cansleep(par->virt_cs, 1);// Assert CS pin to 1
	ret = spi_write(par->spi, par->ssbuf, 2);// this will bring CS pin to low as normal state.
	gpio_set_value_cansleep(par->virt_cs, 0);// Deassert CS pin to 0
	printk("MLCD display cleared\n");

	return ret;
 
}

static void memlcdfb_update_display(struct memlcdfb_par *par){
	//u8 *vmem = par->info->screen_base; // *a = &b new pointer with same address as screen base.
	u8 row, cpy, temp;

	struct spi_transfer t = {
		.tx_buf = par->ssbuf,
		.len = MLCD_RSIZE + 4,
	};
	struct spi_message m;

	par->ssbuf[0] = MLCD_UD;// Display update command
	// Last 2 bytes (53rd and 54th byte) are dummy byte as packet end indicator I guess.
	par->ssbuf[52] = 0x00;
	par->ssbuf[53] = 0x00;
	
	for (row=0; row < CONFIG_SHARP_MLCD_H;row++){ // 1->Display H
		par->ssbuf[1] = msb2lsb[row+1];// reverse bit of row selector (since we need to send the LSB first data).
		
		for(cpy = 0; cpy < MLCD_RSIZE; cpy++){ // we do this MLCD_SIZE times to fill one row of pixels (1 byte each time).
			//temp = *(vmem + cpy * row);
			par->ssbuf[cpy+2] = msb2lsb[(uint8_t)par->info->screen_base[cpy * row]];
		}
		
		// Send data out to display over SPI.
		gpio_set_value_cansleep(par->virt_cs, 1);// Assert CS pin to 1
		spi_message_init(&m);
		spi_message_add_tail(&t, &m);
		spi_sync(par->spi, &m);
		gpio_set_value_cansleep(par->virt_cs, 0);// Deassert CS pin to 0
	}

}

static ssize_t memlcdfb_write(struct fb_info *info, const char __user *buf, size_t count, loff_t *ppos){
/*
	struct memlcdfb_par *par = info->par;
	unsigned long total_size;
	unsigned long p = *ppos;
	void *dst;
	total_size = info->fix.smem_len;

	if (p > total_size){
		printk("MLCD input buf offset is too far!: %ld\n", p);
		return -EINVAL;
	}

	if (count + p > total_size)
		count = total_size - p;

	if (!count)
		return -EINVAL;

	dst = (void __force *) (info->screen_base + p);

	if (copy_from_user(dst, buf, count))
		return -EFAULT;

	memlcdfb_update_display(par);

	*ppos += count;

	return count;	
*/
	struct memlcdfb_par *par = info->par;
	int retval;
	int begin = *ppos;
	int end = *ppos + count;
	
	retval = fb_sys_write(info, buf, count, ppos);
	memlcdfb_update_display(par);
	
	return retval;

}

static int memlcd_blank(int blank_mode, struct fb_info *info){
	struct memlcd_par *par = info->par;

	// if (blank_mode != FB_BLANK_UNBLANK)
		
	// else
	return 0;
}

static void memlcdfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect){
	struct memlcdfb_par *par = info->par;
	sys_fillrect(info, rect);
	memlcdfb_update_display(par);
}

static void memlcdfb_copyarea(struct fb_info *info, const struct fb_copyarea *area){
	struct memlcdfb_par *par = info->par;
	sys_copyarea(info, area);
	memlcdfb_update_display(par);
}

static void memlcdfb_imageblit(struct fb_info *info, const struct fb_image *image){
	struct memlcdfb_par *par = info->par;
	sys_imageblit(info, image);
	memlcdfb_update_display(par);
}

static struct fb_ops memlcdfb_ops = {
	.owner = 		THIS_MODULE,
	.fb_read = 		fb_sys_read,
	.fb_write = 		memlcdfb_write,
	.fb_blank = 		memlcd_blank,
	.fb_fillrect = 		memlcdfb_fillrect,
	.fb_copyarea = 		memlcdfb_copyarea,
	.fb_imageblit = 	memlcdfb_imageblit,
};

static void memlcdfb_deferred_io(struct fb_info *info,
				struct list_head *pagelist)
{
	memlcdfb_update_display(info->par);
}

static struct fb_deferred_io memlcdfb_defio = {
	.delay		= HZ / 10,
	.deferred_io	= memlcdfb_deferred_io,
};

static int memlcdfb_probe(struct spi_device *spi){
	struct device_node *np = spi->dev.of_node;
	struct fb_info *info;
	struct memlcdfb_par *par;
	enum of_gpio_flags of_flags = 0;
	u8 *vmem;
	int ret;

	printk("MLCD probing...\n");
	if (!spi->dev.of_node) {
		dev_err(&spi->dev, "No device tree data found!\n");
		return -EINVAL;
	}

	/* Allocate swapped shadow buffer */
	vmem = vzalloc(MLCD_BUFSIZE);
	
	if (!vmem){
		printk("MLCD buffer allocation failed!\n");
		goto fballoc_fail;
	}

	printk("MLCD buffer mallocated\n");

	info = framebuffer_alloc(sizeof(struct memlcdfb_par), &spi->dev);
	if (!info)
		goto fballoc_fail;
	printk("MLCD fb mallocated\n");	
	
	info->screen_base = (u8 __force __iomem *)vmem;
	info->fix = memlcdfb_fix;
	info->fix.smem_len = MLCD_BUFSIZE;
	//info->fix.smem_start = virt_to_phys(vmem);// In case of kmalloc the vmem.
	info->fbops = &memlcdfb_ops;

	info->var = memlcdfb_var;

	info->fbdefio = &memlcdfb_defio;
	fb_deferred_io_init(info);

	par = info->par;
	par->info = info;
	par->spi = spi;

	// allocate mem for SPI buffer.
	par->ssbuf = kmalloc(MLCD_RSIZE + 4, GFP_KERNEL);

	par->virt_cs = devm_gpiod_get_optional(&spi->dev, "vcs-gpios",
						     GPIOF_INIT_LOW);
	if (!par->virt_cs) {
		printk("failed to request vcs GPIO\n");
		goto init_fail;
	}

	par->virt_cs = of_get_named_gpio_flags(np, "vcs-gpios", 0, &of_flags);
	
 	ret = gpio_is_valid(par->virt_cs);
	if(ret < 0){
		printk("MLCD GPIO invalid\n");
		return ret;
	}
	printk("MLCD gpio found!: %d\n",par->virt_cs);
	
	gpio_set_value_cansleep(par->virt_cs, 0);// Deassert CS pin to 0

	if(gpio_request_one(par->virt_cs, GPIOF_OUT_INIT_LOW, "vcs-gpios")){
		printk("MLCD request vcs GPIO failed\n");
		return -ENODEV;
	}

	//PWM probe
	par->pwm = pwm_get(&spi->dev, NULL);
		if (IS_ERR(par->pwm)) {
			dev_err(&par->spi->dev, "Could not get PWM from device tree!\n");
			return PTR_ERR(par->pwm);
		}
	printk("MLCD pwm probed!\n");

	spi_set_drvdata(spi, info);
	
	printk("MLCD SPI driver data set\n");

	if (memlcdfb_init(par) < 0)
		goto init_fail;
	printk("MLCD Initialzed\n");
	
	printk("MLCD registering fb...\n");
	if (register_framebuffer(info))
		goto fbreg_fail;

	printk("MLCD fb registered\n");	

	printk(KERN_INFO
		"fb%d: %s frame buffer device,\n\tusing %u KB of video memory\n",
		info->node, info->fix.id, MLCD_BUFSIZE);

	return 0;


	/* TODO: release gpios on fail */
init_fail:
	kfree(par->ssbuf);
	printk(KERN_INFO"SHARP memory LCD init failed");

fbreg_fail:
	vfree(vmem);

fballoc_fail:
	unregister_framebuffer(info);
	framebuffer_release(info);
	
	printk(KERN_INFO"SHARP memory LCD fb mem allocate failed");
	return -ENOMEM;
}

static int memlcdfb_remove(struct spi_device *spi){
	struct memlcdfb_par *par = spi_get_drvdata(spi);
	struct fb_info *info = par->info;
	
	if(par->pwm){
		pwm_disable(par->pwm);
		pwm_put(par->pwm);
		printk(KERN_INFO"MLCD PWM disabled");
	}
	
	if(par->ssbuf){
		kfree(par->ssbuf);
		printk(KERN_INFO"MLCD SPI buffer freed");
	}
	
	if(par->spi){
		spi_unregister_device(par->spi);
		printk(KERN_INFO"MLCD SPI bus freed");
	}
	
	if(info->screen_base){
		kfree(info->screen_base);
		printk(KERN_INFO"MLCD Graphic buffer freed");
	}
	
	unregister_framebuffer(info);
	framebuffer_release(info);
	
	fb_deferred_io_cleanup(info);

	return 0;
}

static const struct spi_device_id memlcdfb_ids[] = {
	{ .name = "sharp-memlcd"},
	{ }
};
 
//MODULE_DEVICE_TABLE(spi, memlcd_ids);


static const struct of_device_id memlcdfb_of_match[] = {
	{ .compatible = "sharp,sharp-memlcd"},
	{ }
};
MODULE_DEVICE_TABLE(of, memlcdfb_of_match);

static struct spi_driver memlcd_driver = {
	.driver = {
		.name = "sharp-memlcd",
		.owner = THIS_MODULE, 
		.of_match_table = memlcdfb_of_match,
	},
	.id_table = memlcdfb_ids,
	.probe = memlcdfb_probe,
	.remove = memlcdfb_remove,
};
module_spi_driver(memlcd_driver);

MODULE_DESCRIPTION("Sharp Memory LCD as Framebuffer device");
MODULE_AUTHOR("Thipok Jiamjarapan <thipok17@gmail.com>");
MODULE_LICENSE("GPL");
MODULE_VERSION("1.0");

