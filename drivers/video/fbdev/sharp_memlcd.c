// SPDX-License-Identifier: GPL-2.0
/*
 * Sharp Memory Display Driver.
 *
 * In this case I'm testing with LS027B7DH01
 * But it should work with others by changing 
 * W x H Display resolution
 *
 * Copyright (c) 2021 Thipok Jiamjarapan
 * <thipok17@gmail.com> 
 *
 */

#include <linux/errno.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/vmalloc.h>
#include <linux/slab.h>
#include <linux/init.h>
#include <linux/fb.h>
#include <linux/spi/spi.h>
#include <linux/gpio/consumer.h>
#include <linux/pwm.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>
#include <linux/uaccess.h>

#include <video/sharp_memlcd.h>


//LSB First
#define MLCD_UD 0x80 // Display update command
#define MLCD_MC 0x20 // Dislay internal mem clear
#define MLCD_DM 0x00 // Dummy byte (sending after data update)

#ifndef CONFIG_SHARP_MLCD_W
#define CONFIG_SHARP_MLCD_W 240
#endif

#ifndef CONFIG_SHARP_MLCD_H
#define CONFIG_SHARP_MLCD_H 400
#endif

#define MLCD_RSIZE CONFIG_SHARP_MLCD_W / 8
#define MLCD_BUFSIZE MLCD_RSIZE * CONFIG_SHARP_MLCD_H

#ifndef CONFIG_SHARP_LCD_BUS
#define CONFIG_SHARP_LCD_BUS 1
#endif

#ifndef CONFIG_SHARP_LCD_CS
#define CONFIG_SHARP_LCD_CS 0
#endif


//VCOM inverter control, Required for display refreshing
#define EXTCOM_HI 0x40
#define EXTCOM_LO 0x00


static const struct fb_fix_screeninfo memlcd_fix  = {
	.id = 			"SHARP MEMLCD",
	.type = 		FB_TYPE_PACKED_PIXELS,
	.visual = 		FB_VISUAL_MONO10,
	.xpanstep = 		0,
	.ypanstep = 		0,
	.ywrapstep = 		0,
	.line_length =		MLCD_RSIZE,
	.accel = 		FB_ACCEL_NONE,
};

static const struct fb_var_screeninfo memlcd_var  = {
	.xres = 		CONFIG_SHARP_MLCD_W,
	.yres = 		CONFIG_SHARP_MLCD_H,
	.xres_virtual =		CONFIG_SHARP_MLCD_W,
	.yres_virtual = 	CONFIG_SHARP_MLCD_H,
	.bits_per_pixel = 	1,
};




static uint8_t memlcd_msb2lsb(uint8_t msb){
	msb = (msb & 0xF0) >> 4 | (msb & 0x0F) << 4 ;
	msb = (msb & 0xCC) >> 2 | (msb & 0x33) << 2 ;
	msb = (msb & 0xAA) >> 1 | (msb & 0x55) << 1 ;
	
	return msb;
}

static int memlcd_write_buf(struct memlcd_par *par, uint8_t* val, uint8_t bitLen){
	int ret;
	
	gpio_set_value(par->virt_cs, 1);// Begin 

	ret = spi_write(par->spi, val, bitLen);// Send bytes

	gpio_set_value(par->virt_cs, 0);// End

	return ret;
}

static void memlcd_pwm_on(struct memlcd_par *par){
	struct pwm_args pargs;

	pwm_apply_args(par->pwm);

	pwm_get_args(par->pwm, &pargs);

	par->pwm_period = pargs.period;
	pwm_config(par->pwm, par->pwm_period / 2, par->pwm_period);

	pwm_enable(par->pwm);
	return 0;
}

/* Turn the disply and PWM on
 */
static int memlcd_init(struct memlcd_par *par){

	int ret;
	// EXTCOMIN signal generated by using PWM. Fixed at 60Hz with 1/2 duty cycle
	memlcd_pwm_on(par);

	// Display memory clear
        ret = memlcd_write_buf(par, MLCD_MC,4);

	return ret;
 
}

static void memlcd_update_display(struct memlcd_par *par){
	u8 *vmem = par->info->screen_base;
	u8 SendBuf[2];
	SendBuf[0] = MLCD_UD;
	u8 *DispBuf;
	u16 i;
	u16 offset;

	for (i=0; i < MLCD_BUFSIZE; i++)
		DispBuf[i] = memlcd_msb2lsb(vmem[i]);
	
	u8 row;
	for (row=1; row < (CONFIG_SHARP_MLCD_W + 1);row++){
		SendBuf[1] = memlcd_msb2lsb(row);

		offset = (row-1) * MLCD_RSIZE;

		memlcd_write_buf(par, SendBuf, 2);
		memlcd_write_buf(par, DispBuf + offset, MLCD_RSIZE);	
	}
	
	memlcd_write_buf(par, MLCD_DM, 2);
}

static ssize_t memlcd_write(struct fb_info *info, const char __user *buf, size_t count, loff_t *ppos){
	struct memlcd_par *par = info->par;
	unsigned long total_size;
	unsigned long p = *ppos;
	void *dst;

	total_size = info->fix.smem_len;

	if (p > total_size)
		return -EINVAL;

	if (count + p > total_size)
		count = total_size - p;

	if (!count)
		return -EINVAL;

	dst = (void __force *) (info->screen_base + p);

	if (copy_from_user(dst, buf, count))
		return -EFAULT;

	memlcd_update_display(par);

	*ppos += count;

	return count;	
}

static void memlcd_fillrect(struct fb_info *info, const struct fb_fillrect *rect){
	struct memlcd_par *par = info->par;
	sys_fillrect(info, rect);
	memlcd_update_display(par);
}

static void memlcd_copyarea(struct fb_info *info, const struct fb_copyarea *area){
	struct memlcd_par *par = info->par;
	sys_copyarea(info, area);
	memlcd_update_display(par);
}

static void memlcd_imageblit(struct fb_info *info, const struct fb_image *image){
	struct memlcd_par *par = info->par;
	sys_imageblit(info, image);
	memlcd_update_display(par);
}

static struct fb_ops memlcd_ops = {
	.owner = 		THIS_MODULE,
	.fb_read = 		fb_sys_read,
	.fb_write = 		memlcd_write,
	.fb_fillrect = 		memlcd_fillrect,
	.fb_copyarea = 		memlcd_copyarea,
	.fb_imageblit = 	memlcd_imageblit,
};

static void memlcd_deferred_io(struct fb_info *info,
				struct list_head *pagelist)
{
	memlcd_update_display(info->par);
}

static struct fb_deferred_io memlcd_defio = {
	.delay		= HZ,
	.deferred_io	= memlcd_deferred_io,
};

static int memlcd_probe(struct spi_device *spi){
	struct memlcd_platform_data *pdata = spi->dev.platform_data;
	struct fb_info *info;
	struct memlcd_par *par;
	struct pwm_state state;
	u8 *vmem;
	int vmem_size = MLCD_BUFSIZE; 

	printk("MLCD probing...\n");
	if (!spi->dev.of_node) {
		dev_err(&spi->dev, "No device tree data found!\n");
		return -EINVAL;
	}

	/* Allocate swapped shadow buffer */
	vmem = kzalloc(vmem_size, GFP_KERNEL);
	if (!vmem)
		return -ENOMEM;

	printk("MLCD buffer mallocated\n");

	info = framebuffer_alloc(sizeof(struct memlcd_par), &spi->dev);
	if (!info)
		goto fballoc_fail;
	printk("MLCD fb mallocated\n");	
	
	info->screen_base = (u8 __force __iomem *)vmem;
	info->fix = memlcd_fix;
	info->fix.smem_len = vmem_size;

	info->fbops = &memlcd_ops;

	info->var = memlcd_var;
	/* monochrome pixel format */
	info->var.red.offset = 0;
	info->var.red.length = 1;
	info->var.green.offset = 0;
	info->var.green.length = 1;
	info->var.blue.offset = 0;
	info->var.blue.length = 1;

	info->fbdefio = &memlcd_defio;
	fb_deferred_io_init(info);

	par = info->par;
	par->info = info;
	par->spi = spi;

	par->virt_cs = devm_gpiod_get_optional(&spi->dev, "vcs-gpios",
						     GPIOD_OUT_LOW);
	if (IS_ERR(par->virt_cs)) {
			dev_err(&spi->dev, "failed to request GPIO: %ld\n", PTR_ERR(par->virt_cs));
		goto init_fail;
	}

	printk("MLCD gpio found!\n");	

	int errcode = register_framebuffer(info);
	if (errcode < 0)
		goto fbreg_fail;

	printk("MLCD fb registered\n");
	//PWM probe
	par->pwm = pwm_get(&spi->dev, NULL);
		if (IS_ERR(par->pwm)) {
			dev_err(&par->spi->dev, "Could not get PWM from device tree!\n");
			return PTR_ERR(par->pwm);
		}
	printk("MLCD pwm probed!\n");

	spi_set_drvdata(spi, info);

	if (memlcd_init(par) < 0)
		goto init_fail;

	printk(KERN_INFO
		"fb%d: %s frame buffer device,\n\tusing %d KiB of video memory\n",
		info->node, info->fix.id, vmem_size);

	return 0;


	/* TODO: release gpios on fail */
init_fail:
	spi_set_drvdata(spi, NULL);
	printk(KERN_INFO"SHARP memory LCD init failed");

fbreg_fail:
	framebuffer_release(info);
	printk(KERN_INFO"SHARP memory LCD fbreg failed");

fballoc_fail:
	kvfree(vmem);
	printk(KERN_INFO"SHARP memory LCD fb mem allocate failed");
	return -ENOMEM;
}

static const struct spi_device_id memlcd_ids[] = {
	{ .name = "sharp-memlcd"},
	{ }
};

//MODULE_DEVICE_TABLE(spi, memlcd_ids);


static const struct of_device_id memlcd_of_match[] = {
	{ .compatible = "sharp,sharp-memlcd"},
	{ }
};
MODULE_DEVICE_TABLE(of, memlcd_of_match);

static struct spi_driver memlcd_driver = {
	.driver = {
		.name = "sharp-memlcd",
		.owner = THIS_MODULE, 
		.of_match_table = memlcd_of_match,
	},
	.id_table = memlcd_ids,
	.probe = memlcd_probe,
};
module_spi_driver(memlcd_driver);

MODULE_DESCRIPTION("Sharp Memory LCD as Framebuffer device");
MODULE_AUTHOR("Thipok Jiamjarapan <thipok17@gmail.com>");
MODULE_LICENSE("GPL");
MODULE_VERSION("1.0");

