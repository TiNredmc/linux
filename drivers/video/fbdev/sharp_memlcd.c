// SPDX-License-Identifier: GPL-2.0
/*
 * Sharp Memory Display Driver.
 *
 * In this case I'm testing with LS027B7DH01
 * But it should work with others by changing 
 * W x H Display resolution
 *
 * Copyright (c) 2021 Thipok Jiamjarapan
 * <thipok17@gmail.com> 
 *
 */

#include <linux/errno.h>
#include <linux/string.h>
#include <linux/vmalloc.h>
#include <linux/mm.h>
#include <linux/fb.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <linux/spi/spi.h>
#include <linux/pwm.h>
#include <linux/uaccess.h>
#include <linux/bitrev.h>

#include <video/sharp_memlcd.h>

//LSB First
u8 MLCD_UD = 0x80; // Display update command 0x80(send LSB as MSB).
u8 MLCD_MC = 0x20; // Dislay internal mem clear 0x20
u8 MLCD_DM = 0x00; // Dummy byte (sending after data update)


#ifndef CONFIG_SHARP_MLCD_W
#define CONFIG_SHARP_MLCD_W 400
#endif

#ifndef CONFIG_SHARP_MLCD_H
#define CONFIG_SHARP_MLCD_H 240
#endif

#define MLCD_RSIZE CONFIG_SHARP_MLCD_W / 8
#define MLCD_BUFSIZE MLCD_RSIZE * CONFIG_SHARP_MLCD_H


//VCOM inverter control, Required for display refreshing
//In case of no PWM HW support 
#define EXTCOM_HI 0x40
#define EXTCOM_LO 0x00


static const struct fb_fix_screeninfo memlcdfb_fix  = {
	.id = 			"SHARP MEMLCD_FB",
	.type = 		FB_TYPE_PACKED_PIXELS,
	.visual = 		FB_VISUAL_TRUECOLOR, //FB_VISUAL_MONO01 black px is 1, white is 0
	.xpanstep = 		0,
	.ypanstep = 		0,
	.ywrapstep = 		0,
	.line_length =		CONFIG_SHARP_MLCD_W,
	.accel = 		FB_ACCEL_NONE,
};

static const struct fb_var_screeninfo memlcdfb_var  = {
	.xres = 		CONFIG_SHARP_MLCD_W,
	.yres = 		CONFIG_SHARP_MLCD_H,
	.xres_virtual =		CONFIG_SHARP_MLCD_W,
	.yres_virtual = 	CONFIG_SHARP_MLCD_H,
	/* monochrome pixel format */
	.bits_per_pixel = 	8,
	.grayscale      = 1,
	.red            = {
		.offset = 11,
		.length = 5,
		.msb_right = 0,
	},
	.green          = {
		.offset = 5,
		.length = 6,
		.msb_right = 0,
	},
	.blue           = {
		.offset = 0,
		.length = 5,
		.msb_right = 0,
	},
	.transp         = {
		.offset = 0,
		.length = 0,
		.msb_right = 0,
	},
	.left_margin = 		0,
	.right_margin =		0,
	.upper_margin = 	0,
	.lower_margin = 	0,
	.vmode =		FB_VMODE_NONINTERLACED,
};
/*
static uint8_t memlcd_msb2lsb(uint8_t msb){
	msb = (msb & 0xF0) >> 4 | (msb & 0x0F) << 4 ;
	msb = (msb & 0xCC) >> 2 | (msb & 0x33) << 2 ;
	msb = (msb & 0xAA) >> 1 | (msb & 0x55) << 1 ;
	
	return msb;
}*/

static void memlcdfb_pwm_on(struct memlcdfb_par *par){
	struct pwm_args pargs;

	pwm_apply_args(par->pwm);

	pwm_get_args(par->pwm, &pargs);

	par->pwm_period = pargs.period;
	pwm_config(par->pwm, par->pwm_period / 2, par->pwm_period);

	pwm_enable(par->pwm);
	return 0;
}

/* Turn the disply and PWM on
 */
static int memlcdfb_init(struct memlcdfb_par *par){
	u8 SendBuf[2];
	SendBuf[0] = MLCD_MC;
	SendBuf[1] = MLCD_DM;
	int ret;
	// EXTCOMIN signal generated by using PWM. Fixed at 60Hz with 1/2 duty cycle
	memlcdfb_pwm_on(par);
//	printk("MLCD PWM ON\n");

	// Display memory clear
	//gpio_set_value_cansleep(par->virt_cs, 1);
        ret = spi_write(par->spi, &SendBuf,2);
	//gpio_set_value_cansleep(par->virt_cs, 0);
//	printk("MLCD DISP clear\n");

	return ret;
 
}

static void memlcdfb_update_display(struct memlcdfb_par *par){
	u8 __iomem *vmem; // *a = &b new pointer with same address as screen base.
	u8 SendBuf[2];
	SendBuf[0] = MLCD_UD;
	u8 row, cpy, i;

	//gpio_set_value_cansleep(par->virt_cs, 1);// begin
	for (row=0; row < CONFIG_SHARP_MLCD_H;row++){ // 1->Display H
	
		SendBuf[1] = bitrev8(row+1);// reverse bit of row selector (since we need to send the LSB first data).
		// copy first 2 bytes (CMD + row number)
 		memcpy(par->ssbuf, SendBuf, 2);
		
		par->ssbuf+=2;// move to the pixel data offset.
		
		//COMPRESS 1 byte into 1 bit (we see color intensity > 0 as 1 since we use monochrome Display)
		for(cpy = 0; cpy < MLCD_RSIZE; cpy++){ // we do this 50 times to fill one row of pixels (1 byte each time).
			for(i = 0; i < 8;i++){
				vmem = (void __force *)(par->info->screen_base + i + (cpy * 8));// base address + offset + (8 byte scanning for 8 pixel)
				*par->ssbuf |= ((u8)*vmem ? 0 : 1) << (7-i); // Compress 8bit per pizel to 1bit per pixel.
			} 
		par->ssbuf++;// move to next pixels data byte.
		}
		
		// Send data out to display over SPI.
		spi_write(par->spi, &par->ssbuf, 50 + 4);
	}
	//gpio_set_value_cansleep(par->virt_cs, 0);// end
}

static ssize_t memlcdfb_write(struct fb_info *info, const char __user *buf, size_t count, loff_t *ppos){
	struct memlcdfb_par *par = info->par;
	unsigned long total_size;
	unsigned long p = *ppos;
	void __iomem *dst;
	total_size = info->fix.smem_len;

	if (p > total_size){
		printk("MLCD input buf offset is too far!: %ld\n", p);
		return -EINVAL;
	}

	if (count + p > total_size)
		count = total_size - p;

	if (!count)
		return -EINVAL;

	dst = (void __force *) (info->screen_base + p);

	if (copy_from_user(dst, buf, count))
		return -EFAULT;

	memlcdfb_update_display(par);

	*ppos += count;

	return count;	
}
/*
static int memlcd_blank(int blank_mode, struct fb_info *info){
	struct memlcd_par *par = info->par;

	if (blank_mode != FB_BLANK_UNBLANK)
		gpio_set_value_cansleep(par->virt_cs, 0);// turn screen off
	else
		gpio_set_value_cansleep(par->virt_cs, 1);// turn screen on
}*/

static void memlcdfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect){
	struct memlcdfb_par *par = info->par;
	sys_fillrect(info, rect);
	memlcdfb_update_display(par);
}

static void memlcdfb_copyarea(struct fb_info *info, const struct fb_copyarea *area){
	struct memlcdfb_par *par = info->par;
	sys_copyarea(info, area);
	memlcdfb_update_display(par);
}

static void memlcdfb_imageblit(struct fb_info *info, const struct fb_image *image){
	struct memlcdfb_par *par = info->par;
	sys_imageblit(info, image);
	memlcdfb_update_display(par);
}

static struct fb_ops memlcdfb_ops = {
	.owner = 		THIS_MODULE,
	.fb_read = 		fb_sys_read,
	.fb_write = 		memlcdfb_write,
//	.fb_blank = 		memlcd_blank,
	.fb_fillrect = 		memlcdfb_fillrect,
	.fb_copyarea = 		memlcdfb_copyarea,
	.fb_imageblit = 	memlcdfb_imageblit,
};

static void memlcdfb_deferred_io(struct fb_info *info,
				struct list_head *pagelist)
{
	memlcdfb_update_display(info->par);
}

static struct fb_deferred_io memlcdfb_defio = {
	.delay		= HZ / 50,
	.deferred_io	= memlcdfb_deferred_io,
};

static int memlcdfb_probe(struct spi_device *spi){
	struct device_node *np = spi->dev.of_node;
	struct fb_info *info;
	struct memlcdfb_par *par;
	enum of_gpio_flags of_flags = 0;
	u8 *vmem;
	u32 vmem_size = CONFIG_SHARP_MLCD_W * CONFIG_SHARP_MLCD_H; 
	int ret;

	printk("MLCD probing...\n");
	if (!spi->dev.of_node) {
		dev_err(&spi->dev, "No device tree data found!\n");
		return -EINVAL;
	}

	/* Allocate swapped shadow buffer */
	vmem = vzalloc(vmem_size);
	
	if (!vmem){
		printk("MLCD buffer allocation failed!\n");
		goto fballoc_fail;
	}

//	printk("MLCD buffer mallocated\n");

	info = framebuffer_alloc(sizeof(struct memlcdfb_par), &spi->dev);
	if (!info)
		goto fballoc_fail;
//	printk("MLCD fb mallocated\n");	
	
	info->screen_base = (u8 __force __iomem *)vmem;
	info->fix = memlcdfb_fix;
	info->fix.smem_len = vmem_size;
//	info->fix.smem_start = __pa(vmem);
//	printk("MLCD mem bank at %lx\n",info->fix.smem_start);
	info->fbops = &memlcdfb_ops;

	info->var = memlcdfb_var;

	info->fbdefio = &memlcdfb_defio;
	fb_deferred_io_init(info);

	par = info->par;
	par->info = info;
	par->spi = spi;

	// allocate mem for SPI buffer.
	par->ssbuf = vzalloc(MLCD_RSIZE + 4);

	par->virt_cs = devm_gpiod_get_optional(&spi->dev, "vcs-gpios",
						     GPIOF_INIT_LOW);
	if (IS_ERR(par->virt_cs)) {
		printk("failed to request vcs GPIO\n");
		goto init_fail;
	}

	par->virt_cs = of_get_named_gpio_flags(np, "vcs-gpios", 0, &of_flags);
	
 	ret = gpio_is_valid(par->virt_cs);
	if(ret < 0){
		printk("MLCD GPIO invalid\n");
		return ret;
	}
//	printk("MLCD gpio found!: %d\n",par->virt_cs);

	if(gpio_request_one(par->virt_cs, GPIOF_OUT_INIT_LOW, "vcs-gpios")){
		printk("MLCD request vcs GPIO failed\n");
		return -ENODEV;
	}

	//PWM probe
	par->pwm = pwm_get(&spi->dev, NULL);
		if (IS_ERR(par->pwm)) {
			dev_err(&par->spi->dev, "Could not get PWM from device tree!\n");
			return PTR_ERR(par->pwm);
		}
//	printk("MLCD pwm probed!\n");

	spi_set_drvdata(spi, info);
	
//	printk("MLCD SPI driver data set\n");

	if (memlcdfb_init(par) < 0)
		goto init_fail;
//	printk("MLCD Initialzed\n");

//	printk("MLCD registering fb...\n");
	if (register_framebuffer(info))
		goto fbreg_fail;

	printk("MLCD fb registered\n");	

	printk(KERN_INFO
		"fb%d: %s frame buffer device,\n\tusing %u KiB of video memory\n",
		info->node, info->fix.id, vmem_size);

	return 0;


	/* TODO: release gpios on fail */
init_fail:
	spi_set_drvdata(spi, NULL);
	printk(KERN_INFO"SHARP memory LCD init failed");

fbreg_fail:
	framebuffer_release(info);
	printk(KERN_INFO"SHARP memory LCD fbreg failed");

fballoc_fail:
	framebuffer_release(info);
	vfree(vmem);
	printk(KERN_INFO"SHARP memory LCD fb mem allocate failed");
	return -ENOMEM;
}

static int memlcdfb_remove(struct spi_device *spi){
	struct memlcdfb_par *par = spi_get_drvdata(spi);
	struct fb_info *info = par->info;
	
	pwm_disable(par->pwm);
	pwm_put(par->pwm);
	
	spi_unregister_device(par->spi);	
	
	fb_deferred_io_cleanup(info);
	vfree(info->screen_base);
	framebuffer_release(info);

	return 0;
}

static const struct spi_device_id memlcdfb_ids[] = {
	{ .name = "sharp-memlcd"},
	{ }
};
 
//MODULE_DEVICE_TABLE(spi, memlcd_ids);


static const struct of_device_id memlcdfb_of_match[] = {
	{ .compatible = "sharp,sharp-memlcd"},
	{ }
};
MODULE_DEVICE_TABLE(of, memlcdfb_of_match);

static struct spi_driver memlcd_driver = {
	.driver = {
		.name = "sharp-memlcd",
		.owner = THIS_MODULE, 
		.of_match_table = memlcdfb_of_match,
	},
	.id_table = memlcdfb_ids,
	.probe = memlcdfb_probe,
	.remove = memlcdfb_remove,
};
module_spi_driver(memlcd_driver);

MODULE_DESCRIPTION("Sharp Memory LCD as Framebuffer device");
MODULE_AUTHOR("Thipok Jiamjarapan <thipok17@gmail.com>");
MODULE_LICENSE("GPL");
MODULE_VERSION("1.0");

